<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://hevia.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hevia.github.io/blog/" rel="alternate" type="text/html" /><updated>2021-05-13T21:49:05-05:00</updated><id>https://hevia.github.io/blog/feed.xml</id><title type="html">SNAKES!</title><subtitle>Personal blog for Anthony Hevia</subtitle><entry><title type="html">Today I Learned</title><link href="https://hevia.github.io/blog/til/2021/05/04/Today-I-Learned.html" rel="alternate" type="text/html" title="Today I Learned" /><published>2021-05-04T00:00:00-05:00</published><updated>2021-05-04T00:00:00-05:00</updated><id>https://hevia.github.io/blog/til/2021/05/04/Today-I-Learned</id><author><name></name></author><category term="TIL" /><summary type="html">May 13th, 2021 Service Workers operate on threads separate from main Service workers required HTTPS to be used ServiceWorkers + CacheStorage is what helps lead to such huge performance gains You can invalidate an old service worker cache by adopting a new name The cache used by service workers is separate from the browser cache iframes use their own browsing context which requires increased memory from the browser Service Workers are excuted in a ServiceWorkerGlobalScope context that have no access to DOM Service workers cannot be used when the user is in private browsing mode You have control over the cache lifetime for your site/service workers You can register service workers to listen for certain events (such as fetch) and whenever the client emits that event, the service workers will intercept the request &amp;amp; perform the work. You can then cache the result You can have the client install new service workers by also updating the associated cache version ServiceWorkers also enable push notifications &amp;amp; background sync APIs</summary></entry></feed>